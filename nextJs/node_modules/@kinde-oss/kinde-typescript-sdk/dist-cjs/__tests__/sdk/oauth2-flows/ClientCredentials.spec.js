"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const ClientCredentials_1 = require("../../../sdk/oauth2-flows/ClientCredentials");
const utilities_1 = require("../../../sdk/utilities");
const version_1 = require("../../../sdk/version");
const mocks = __importStar(require("../../mocks"));
describe('ClientCredentials', () => {
    const clientConfig = {
        authDomain: 'https://local-testing@kinde.com',
        logoutRedirectURL: 'http://app-domain.com',
        clientSecret: 'client-secret',
        clientId: 'client-id',
    };
    const { sessionManager } = mocks;
    describe('new ClientCredentials()', () => {
        it('can construct ClientCredentials instance', () => {
            expect(() => new ClientCredentials_1.ClientCredentials(clientConfig)).not.toThrowError();
        });
    });
    describe('getToken()', () => {
        const tokenEndpoint = `${clientConfig.authDomain}/oauth2/token`;
        const body = new URLSearchParams({
            grant_type: 'client_credentials',
            scope: ClientCredentials_1.ClientCredentials.DEFAULT_TOKEN_SCOPES,
            client_id: clientConfig.clientId,
            client_secret: clientConfig.clientSecret,
        });
        const headers = new Headers();
        headers.append(...(0, version_1.getSDKHeader)());
        headers.append('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
        afterEach(async () => {
            await sessionManager.destroySession();
            mocks.fetchClient.mockClear();
        });
        it('throws an exception when fetching access token returns an error response', async () => {
            const errorDescription = 'error_description';
            mocks.fetchClient.mockResolvedValue({
                json: () => ({
                    error: 'error',
                    [errorDescription]: errorDescription,
                }),
            });
            const client = new ClientCredentials_1.ClientCredentials(clientConfig);
            await expect(async () => {
                await client.getToken(sessionManager);
            }).rejects.toThrow(errorDescription);
            expect(mocks.fetchClient).toHaveBeenCalled();
        });
        it('return access token if an unexpired token is available in memory', async () => {
            const { authDomain } = clientConfig;
            const { token: mockAccessToken } = mocks.getMockAccessToken(authDomain);
            await (0, utilities_1.commitTokenToMemory)(sessionManager, mockAccessToken, 'access_token');
            const client = new ClientCredentials_1.ClientCredentials(clientConfig);
            const accessToken = await client.getToken(sessionManager);
            expect(mocks.fetchClient).not.toHaveBeenCalled();
            expect(accessToken).toBe(mockAccessToken);
        });
        it('fetches an access token if no access token is available in memory', async () => {
            const { token: mockAccessToken } = mocks.getMockAccessToken(clientConfig.authDomain);
            mocks.fetchClient.mockResolvedValue({
                json: () => ({ access_token: mockAccessToken }),
            });
            const client = new ClientCredentials_1.ClientCredentials(clientConfig);
            const accessToken = await client.getToken(sessionManager);
            expect(accessToken).toBe(mockAccessToken);
            expect(mocks.fetchClient).toHaveBeenCalledTimes(1);
        });
        it('fetches an access token if available access token is expired', async () => {
            const { token: mockAccessToken } = mocks.getMockAccessToken(clientConfig.authDomain, true);
            mocks.fetchClient.mockResolvedValue({
                json: () => ({ access_token: mockAccessToken }),
            });
            const client = new ClientCredentials_1.ClientCredentials(clientConfig);
            const accessToken = await client.getToken(sessionManager);
            expect(accessToken).toBe(mockAccessToken);
            expect(mocks.fetchClient).toHaveBeenCalledTimes(1);
            expect(mocks.fetchClient).toHaveBeenCalledWith(tokenEndpoint, {
                method: 'POST',
                headers,
                body,
            });
        });
        it('overrides scope and audience in token request body is provided', async () => {
            const { token: mockAccessToken } = mocks.getMockAccessToken(clientConfig.authDomain);
            mocks.fetchClient.mockResolvedValue({
                json: () => ({ access_token: mockAccessToken }),
            });
            const expectedScope = 'test-scope';
            const expectedAudience = 'test-audience';
            const client = new ClientCredentials_1.ClientCredentials({
                ...clientConfig,
                audience: expectedAudience,
                scope: expectedScope,
            });
            const expectedBody = new URLSearchParams({
                grant_type: 'client_credentials',
                scope: expectedScope,
                client_id: clientConfig.clientId,
                client_secret: clientConfig.clientSecret,
                audience: expectedAudience,
            });
            await client.getToken(sessionManager);
            expect(mocks.fetchClient).toHaveBeenCalledWith(tokenEndpoint, {
                method: 'POST',
                headers,
                body: expectedBody,
            });
        });
        it('commits access token to memory, when a new one is fetched', async () => {
            const mockAccessToken = mocks.getMockAccessToken(clientConfig.authDomain);
            mocks.fetchClient.mockResolvedValue({
                json: () => ({ access_token: mockAccessToken }),
            });
            const client = new ClientCredentials_1.ClientCredentials(clientConfig);
            await client.getToken(sessionManager);
            expect(mocks.fetchClient).toHaveBeenCalledTimes(1);
            expect(await sessionManager.getSessionItem('access_token')).toBe(mockAccessToken);
        });
    });
});
