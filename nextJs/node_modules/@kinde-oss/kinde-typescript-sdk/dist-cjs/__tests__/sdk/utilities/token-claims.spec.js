"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const mocks = __importStar(require("../../mocks"));
const utilities_1 = require("../../../sdk/utilities");
describe('token-claims', () => {
    let mockAccessToken;
    let mockIdToken;
    const authDomain = 'https://local-testing@kinde.com';
    const { sessionManager } = mocks;
    beforeEach(async () => {
        mockAccessToken = mocks.getMockAccessToken();
        mockIdToken = mocks.getMockIdToken();
        await sessionManager.setSessionItem('access_token_payload', mockAccessToken.payload);
        await sessionManager.setSessionItem('id_token_payload', mockIdToken.payload);
        await sessionManager.setSessionItem('access_token', mockAccessToken.token);
        await sessionManager.setSessionItem('id_token', mockIdToken.token);
    });
    afterEach(async () => {
        await sessionManager.destroySession();
    });
    describe('getClaimValue', () => {
        it('returns value for a token claim if claim exists', () => {
            Object.keys(mockAccessToken.payload).forEach(async (name) => {
                const claimValue = await (0, utilities_1.getClaimValue)(sessionManager, name);
                const tokenPayload = mockAccessToken.payload;
                expect(claimValue).toBe(tokenPayload[name]);
            });
        });
        it('return null if claim does not exist', async () => {
            const claimName = 'non-existant-claim';
            const claimValue = await (0, utilities_1.getClaimValue)(sessionManager, claimName);
            expect(claimValue).toBe(null);
        });
    });
    describe('getClaim', () => {
        it('returns value for a token claim if claim exists', () => {
            Object.keys(mockAccessToken.payload).forEach(async (name) => {
                const claim = await (0, utilities_1.getClaim)(sessionManager, name);
                const tokenPayload = mockAccessToken.payload;
                expect(claim).toStrictEqual({ name, value: tokenPayload[name] });
            });
        });
        it('return null if claim does not exist', async () => {
            const claimName = 'non-existant-claim';
            const claim = await (0, utilities_1.getClaim)(sessionManager, claimName);
            expect(claim).toStrictEqual({ name: claimName, value: null });
        });
    });
    describe('getPermission', () => {
        it('return orgCode and isGranted = true if permission is given', () => {
            const { permissions } = mockAccessToken.payload;
            permissions.forEach(async (permission) => {
                expect(await (0, utilities_1.getPermission)(sessionManager, permission)).toStrictEqual({
                    orgCode: mockAccessToken.payload.org_code,
                    isGranted: true,
                });
            });
        });
        it('return isGranted = false is permission is not given', async () => {
            const orgCode = mockAccessToken.payload.org_code;
            const permissionName = 'non-existant-permission';
            expect(await (0, utilities_1.getPermission)(sessionManager, permissionName)).toStrictEqual({
                orgCode,
                isGranted: false,
            });
        });
    });
    describe('getUserOrganizations', () => {
        it('lists all user organizations using id token', async () => {
            const orgCodes = mockIdToken.payload.org_codes;
            expect(await (0, utilities_1.getUserOrganizations)(sessionManager)).toStrictEqual({
                orgCodes,
            });
        });
    });
    describe('getOrganization', () => {
        it('returns organization code using accesss token', async () => {
            const orgCode = mockAccessToken.payload.org_code;
            expect(await (0, utilities_1.getOrganization)(sessionManager)).toStrictEqual({ orgCode });
        });
    });
});
