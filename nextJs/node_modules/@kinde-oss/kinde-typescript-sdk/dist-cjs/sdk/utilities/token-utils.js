"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isTokenExpired = exports.commitUserToMemory = exports.getUserFromMemory = exports.getAccessToken = exports.getRefreshToken = exports.commitTokensToMemory = exports.commitTokenToMemory = void 0;
/**
 * Parses a provided JWT token to extract the payload segment of said
 * token.
 * @param token {string}
 * @returns {any}
 */
const getTokenPayload = (token) => {
    try {
        return JSON.parse(atob(token.split('.')[1]));
    }
    catch (e) {
        return null;
    }
};
/**
 * Extracts the payload from the provided idToken and saves the extracted
 * payload to the current session.
 * @param {SessionManager} sessionManager
 * @param {string} idToken
 * @returns {void}
 */
const commitUserToMemoryFromToken = async (sessionManager, idToken) => {
    const idTokenPayload = getTokenPayload(idToken);
    const user = {
        family_name: idTokenPayload.family_name,
        given_name: idTokenPayload.given_name,
        picture: idTokenPayload.picture ?? null,
        email: idTokenPayload.email,
        id: idTokenPayload.sub,
    };
    await sessionManager.setSessionItem('user', user);
};
/**
 * Saves the provided token and its extracted payload to the current session.
 * @param {SessionManager} sessionManager
 * @param {string} token
 * @param {TokenType} type
 */
const commitTokenToMemory = async (sessionManager, token, type) => {
    const tokenPayload = getTokenPayload(token);
    await sessionManager.setSessionItem(type, token);
    if (type === 'access_token') {
        await sessionManager.setSessionItem('access_token_payload', tokenPayload);
    }
    else if (type === 'id_token') {
        await sessionManager.setSessionItem('id_token_payload', tokenPayload);
        await commitUserToMemoryFromToken(sessionManager, token);
    }
};
exports.commitTokenToMemory = commitTokenToMemory;
/**
 * Saves the access, refresh and id tokens provided in the `TokenCollection`
 * object to the current session.
 * @param {SessionManager} sessionManager
 * @param tokens
 */
const commitTokensToMemory = async (sessionManager, tokens) => {
    await Promise.all([
        (0, exports.commitTokenToMemory)(sessionManager, tokens.refresh_token, 'refresh_token'),
        (0, exports.commitTokenToMemory)(sessionManager, tokens.access_token, 'access_token'),
        (0, exports.commitTokenToMemory)(sessionManager, tokens.id_token, 'id_token'),
    ]);
};
exports.commitTokensToMemory = commitTokensToMemory;
/**
 * Extracts the refresh token from current session returns null if the
 * token is not found.
 * @param {SessionManager} sessionManager
 * @returns {string | null}
 */
const getRefreshToken = async (sessionManager) => {
    return await sessionManager.getSessionItem('refresh_token');
};
exports.getRefreshToken = getRefreshToken;
/**
 * Extracts the access token from current session returns null if the
 * token is not found.
 * @param {SessionManager} sessionManager
 * @returns {string | null}
 */
const getAccessToken = async (sessionManager) => {
    return await sessionManager.getSessionItem('access_token');
};
exports.getAccessToken = getAccessToken;
/**
 * Extracts the user information from the current session returns null if
 * the token is not found.
 * @param {SessionManager} sessionManager
 * @returns {string | null}
 */
const getUserFromMemory = async (sessionManager) => {
    return await sessionManager.getSessionItem('user');
};
exports.getUserFromMemory = getUserFromMemory;
/**
 * Saves the provided user details as `UserType` to the current session.
 * @param {SessionManager} sessionManager
 * @param {UserType} user
 */
const commitUserToMemory = async (sessionManager, user) => {
    await sessionManager.setSessionItem('user', user);
};
exports.commitUserToMemory = commitUserToMemory;
/**
 * Checks if the provided JWT token is valid (expired or not).
 * @param {string | null} token
 * @returns {boolean} is expired or not
 */
const isTokenExpired = (token) => {
    if (!token)
        return true;
    const currentUnixTime = Math.floor(Date.now() / 1000);
    const tokenPayload = getTokenPayload(token);
    return currentUnixTime >= tokenPayload.exp;
};
exports.isTokenExpired = isTokenExpired;
